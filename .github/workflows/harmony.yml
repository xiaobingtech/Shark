name: HarmonyOS Release Build Deploy to AppGallery

on:
  push:
    tags:
      - 'v*'  # 只对 v 开头的 tag 触发，例如 v1.0.0
  workflow_dispatch:  # 允许手动触发
    inputs:
      debug_unmask:
        description: '临时显示敏感变量真实值 (base64)'
        required: false
        default: false
        type: boolean

jobs:
  build-and-release:
    runs-on: ubuntu-latest  # 使用 Ubuntu Linux 环境
    # runs-on: self-hosted
    
    # 为 Release 添加策略
    permissions:
      contents: write  # 需要写入权限来创建 Release
      actions: read
      checks: read

    steps:
      # 1. 检出代码（包含签名文件和 tag 信息）
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 获取完整历史，确保所有文件
          ref: ${{ github.ref }}

      # 2. 获取 tag 信息并设置环境变量
      - name: Setup Tag Information
        run: |
          # 获取 tag 名称（去掉 refs/tags/ 前缀）
          TAG_NAME=${GITHUB_REF#refs/tags/}
          echo "TAG_NAME=$TAG_NAME" >> $GITHUB_ENV
          
          # 设置 Release 名称（使用 tag 名称）
          echo "RELEASE_NAME=$TAG_NAME" >> $GITHUB_ENV
          
          # 从 tag 名称提取版本号（去掉 v 前缀）
          VERSION=${TAG_NAME#v}
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          
          echo "Tag: $TAG_NAME"
          echo "Version: $VERSION"
          echo "Release Name: $RELEASE_NAME"

      - name: Inject GitHub Run Id
        run: |
          RUN_ID=${{ github.run_id }}
          if [[ "$OSTYPE" == "darwin"* ]]; then
            sed -i '' "s/^  public static readonly GITHUB_RUN_ID: string = '.*';/  public static readonly GITHUB_RUN_ID: string = '$RUN_ID';/" common/src/main/ets/constant/CommonConstants.ets
          else
            sed -i "s/^  public static readonly GITHUB_RUN_ID: string = '.*';/  public static readonly GITHUB_RUN_ID: string = '$RUN_ID';/" common/src/main/ets/constant/CommonConstants.ets
          fi

      # 3. 设置环境变量
      - name: Set Environment Variables
        run: |
          echo "JAVA_HOME=/opt/jdk-17" >> $GITHUB_ENV
          echo "COMMANDLINE_TOOL_DIR=/opt" >> $GITHUB_ENV
          echo "PROJECT_PATH=${{ github.workspace }}" >> $GITHUB_ENV
          echo "SIGNING_KEY_ALIAS=${{ secrets.SIGNING_KEY_ALIAS }}" >> $GITHUB_ENV
          echo "KEYSTORE_PASSWORD=${{ secrets.KEYSTORE_PASSWORD }}" >> $GITHUB_ENV
          
          # 设置 DevEco SDK 路径
          echo "DEVECO_SDK_HOME=/opt/command-line-tools/sdk" >> $GITHUB_ENV

      # 3.1 调试：临时显示敏感变量真实值（base64，解码：echo XXX | base64 -d）
      - name: Debug Unmask (base64)
        if: github.event.inputs.debug_unmask == 'true'
        env:
          SIGNING_KEY_ALIAS: ${{ secrets.SIGNING_KEY_ALIAS }}
          KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
          HUAWEI_CLIENT_ID: ${{ secrets.HUAWEI_CLIENT_ID }}
          HUAWEI_CLIENT_SECRET: ${{ secrets.HUAWEI_CLIENT_SECRET }}
          HUAWEI_APP_ID: ${{ secrets.HUAWEI_APP_ID }}
        run: |
          echo "=== 敏感变量 (base64，本地解码: echo XXX | base64 -d) ==="
          echo "SIGNING_KEY_ALIAS=$(echo -n "$SIGNING_KEY_ALIAS" | base64)"
          echo "KEYSTORE_PASSWORD=$(echo -n "$KEYSTORE_PASSWORD" | base64)"
          echo "HUAWEI_CLIENT_ID=$(echo -n "$HUAWEI_CLIENT_ID" | base64)"
          echo "HUAWEI_CLIENT_SECRET=$(echo -n "$HUAWEI_CLIENT_SECRET" | base64)"
          echo "HUAWEI_APP_ID=$(echo -n "$HUAWEI_APP_ID" | base64)"
          echo "=========================================="

      # 4. 安装 JDK 17
      - name: Setup JDK 17
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'

      # 5. 下载并合并命令行工具分卷包（仅 Linux，Mac 本地已安装）
      - name: Download Commandline Tools (Split Archives)
        if: runner.os == 'Linux'
        run: |
          # 创建临时目录
          mkdir -p /tmp/cli-tools
          cd /tmp/cli-tools
          
          # 分卷文件的基础 URL
          BASE_URL="https://raw.githubusercontent.com/xiaobingtech/commandline-tools-linux-x64-6.0.2.640/refs/heads/main"
          
          echo "开始下载命令行工具分卷包..."
          
          # 下载所有分卷文件（001 到 019）
          for i in {001..019}; do
            FILENAME="commandline-tools-linux-x64-6.0.2.640.7z.$i"
            URL="$BASE_URL/$FILENAME"
            echo "下载: $FILENAME"
            
            # 使用重试机制下载
            for attempt in {1..3}; do
              echo "下载尝试 $attempt..."
              if wget -q --timeout=30 "$URL" -O "$FILENAME"; then
                echo "✅ 下载成功: $FILENAME ($(du -h "$FILENAME" | cut -f1))"
                break
              else
                echo "❌ 下载失败 $attempt: $FILENAME"
                if [ $attempt -eq 3 ]; then
                  echo "❌ 下载失败: $FILENAME，终止构建"
                  exit 1
                fi
                sleep 3
              fi
            done
          done
          
          echo "所有分卷下载完成"
          echo "文件列表:"
          ls -lh *.7z.*
          
          # 验证文件数量
          FILE_COUNT=$(ls -1 *.7z.* 2>/dev/null | wc -l)
          echo "找到 $FILE_COUNT 个分卷文件"
          
          if [ "$FILE_COUNT" -ne 19 ]; then
            echo "❌ 错误: 期望 19 个分卷文件，但找到 $FILE_COUNT 个"
            exit 1
          fi
          
          # 合并文件
          echo "合并分卷文件..."
          COMBINED_FILE="commandline-tools-linux-x64-6.0.2.640.7z"
          cat commandline-tools-linux-x64-6.0.2.640.7z.* > "$COMBINED_FILE"
          
          # 验证合并后的文件
          if [ -f "$COMBINED_FILE" ]; then
            COMBINED_SIZE=$(du -h "$COMBINED_FILE" | cut -f1)
            echo "✅ 合并成功: $COMBINED_FILE ($COMBINED_SIZE)"
          else
            echo "❌ 合并失败"
            exit 1
          fi
          
          # 创建目标目录
          sudo mkdir -p /opt/command-line-tools
          sudo chown -R runner:runner /opt/command-line-tools
          
          echo "解压 7z 文件..."
          
          # 安装解压工具（如果不存在）
          if ! command -v 7z &> /dev/null; then
            echo "安装 p7zip 工具..."
            sudo apt-get update
            sudo apt-get install -y p7zip-full
          fi
          
          if ! command -v unzip &> /dev/null; then
            echo "安装 unzip 工具..."
            sudo apt-get install -y unzip
          fi
          
          # 先列出7z文件内容，查看内部结构
          echo "列出7z文件内容..."
          7z l "$COMBINED_FILE" | head -20
          
          # 创建解压目录
          mkdir -p extract
          
          echo "第一步：解压 7z 文件..."
          # 解压7z文件
          7z x "$COMBINED_FILE" -oextract -y
          
          if [ $? -eq 0 ]; then
            echo "✅ 7z 解压成功"
            
            # 查看解压出的文件
            echo "解压出的文件:"
            ls -la extract/
            
            # 查找 zip 文件
            ZIP_FILE=$(find extract -name "*.zip" -type f | head -1)
            if [ -n "$ZIP_FILE" ]; then
              echo "找到 ZIP 文件: $ZIP_FILE"
              
              echo "第二步：解压 ZIP 文件到 /opt/command-line-tools..."
              # 解压 zip 文件
              unzip "$ZIP_FILE" -d /opt/command-line-tools
              
              if [ $? -eq 0 ]; then
                echo "✅ ZIP 解压成功"
                
                # 检查解压结果
                echo "检查解压目录内容..."
                find /opt/command-line-tools -maxdepth 2 -type f | head -10
                
                # 计算文件数量
                FILE_COUNT=$(find /opt/command-line-tools -type f 2>/dev/null | wc -l)
                echo "解压出 $FILE_COUNT 个文件"
                
                # 检查关键工具
                echo "查找关键工具:"
                for tool in hvigorw ohpm hdc hap-sign-tool.jar; do
                  TOOL_PATH=$(find /opt/command-line-tools -name "$tool" -type f 2>/dev/null | head -1)
                  if [ -n "$TOOL_PATH" ]; then
                    echo "✅ 找到 $tool: $TOOL_PATH"
                  else
                    echo "⚠️ 未找到 $tool"
                  fi
                done
                
                # 检查是否有嵌套的目录结构，如果有则调整
                if [ -d "/opt/command-line-tools/command-line-tools" ]; then
                  echo "发现嵌套目录结构，正在调整..."
                  mv /opt/command-line-tools/command-line-tools/* /opt/command-line-tools/
                  rm -rf /opt/command-line-tools/command-line-tools
                fi
                
              else
                echo "❌ ZIP 解压失败"
                exit 1
              fi
            else
              # 如果没有找到 zip 文件，尝试其他格式
              echo "未找到 ZIP 文件，查找其他格式..."
              ALL_FILES=$(find extract -type f)
              echo "所有解压文件:"
              echo "$ALL_FILES"
              
              # 尝试直接移动所有文件
              mv extract/* /opt/command-line-tools/ 2>/dev/null || true
              
              FILE_COUNT=$(find /opt/command-line-tools -type f 2>/dev/null | wc -l)
              echo "移动了 $FILE_COUNT 个文件到 /opt/command-line-tools"
            fi
          else
            echo "❌ 7z 解压失败"
            exit 1
          fi
          
          # 设置目录权限
          sudo chmod -R 755 /opt/command-line-tools
          
          # 清理临时文件
          cd /
          rm -rf /tmp/cli-tools
          echo "临时文件清理完成"

      # 6. 根据实际位置配置环境变量
      - name: Configure Environment
        run: |
          # 查找工具的实际位置
          HVIGORW_PATH=$(find /opt -name "hvigorw" -type f 2>/dev/null | head -1)
          OHPM_PATH=$(find /opt -name "ohpm" -type f 2>/dev/null | head -1)
          HDC_PATH=$(find /opt -name "hdc" -type f 2>/dev/null | head -1)
          
          # 提取目录路径并添加到 PATH
          if [ -n "$HVIGORW_PATH" ]; then
            HVIGORW_DIR=$(dirname "$HVIGORW_PATH")
            echo "$HVIGORW_DIR" >> $GITHUB_PATH
          fi
          
          if [ -n "$OHPM_PATH" ]; then
            OHPM_DIR=$(dirname "$OHPM_PATH")
            echo "$OHPM_DIR" >> $GITHUB_PATH
          fi
          
          if [ -n "$HDC_PATH" ]; then
            HDC_DIR=$(dirname "$HDC_PATH")
            echo "$HDC_DIR" >> $GITHUB_PATH
          fi
          
          # 检查是否有通用的 bin 目录
          BIN_DIRS=$(find /opt/command-line-tools -name "bin" -type d 2>/dev/null)
          for dir in $BIN_DIRS; do
            echo "$dir" >> $GITHUB_PATH
          done
          
          # 设置 DEVECO_SDK_HOME 到 PATH
          echo "/opt/command-line-tools/sdk" >> $GITHUB_PATH

      # 7. 创建符号链接
      - name: Create Symbolic Links
        run: |
          # 为工具创建符号链接到 /usr/local/bin
          for tool in hvigorw ohpm hdc; do
            TOOL_PATH=$(find /opt -name "$tool" -type f 2>/dev/null | head -1)
            if [ -n "$TOOL_PATH" ]; then
              sudo ln -sf "$TOOL_PATH" /usr/local/bin/
            fi
          done

      # 8. 配置 npm 和 ohpm 镜像
      - name: Configure Registries
        run: |
          npm config set registry https://repo.huaweicloud.com/repository/npm/
          npm config set "@ohos:registry" https://repo.harmonyos.com/npm/
          
          if command -v ohpm &> /dev/null; then
            ohpm config set registry https://ohpm.openharmony.cn/ohpm/
            ohpm config set strict_ssl false
          fi

      # 9. 安装系统依赖
      - name: Install System Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libgl1-mesa-dev

      # 10. 安装项目依赖
      - name: Install Dependencies
        run: |
          cd ${{ env.PROJECT_PATH }}
          
          # 确保环境变量
          export DEVECO_SDK_HOME=/opt/command-line-tools/sdk
          
          # 安装 npm 依赖
          if [ -f "package.json" ]; then
            npm install
          fi
          
          # 安装 ohpm 依赖
          if [ -f "oh-package.json5" ] || [ -f "oh-package.json" ]; then
            if command -v ohpm &> /dev/null; then
              ohpm install --all
            fi
          fi

      # 11. 构建 release APP
      - name: Build Release APP
        run: |
          cd ${{ env.PROJECT_PATH }}
          echo "开始构建 release APP..."
          echo "版本: ${{ env.VERSION }}"
          echo "Tag: ${{ env.TAG_NAME }}"
          
          # 确保环境变量已设置
          export DEVECO_SDK_HOME=/opt/command-line-tools/sdk
          
          # 先清理
          hvigorw clean --no-daemon
          
          # 构建 APP
          hvigorw assembleApp --mode project -p product=default --no-daemon
          echo "Release APP 构建完成"
          
          # 检查构建产物
          echo "=== 构建产物 ==="
          find . -name "*.app" -type f 2>/dev/null
          find . -name "*.hap" -type f 2>/dev/null

      # 12. 签名 release APP
      - name: Sign Release APP
        run: |
          cd ${{ env.PROJECT_PATH }}
          
          echo "开始签名 release APP..."
          
          # 查找未签名的 APP 文件（.app 文件）
          UNSIGNED_APP=$(find . -name "*release-unsigned.app" -type f | head -1)
          if [ -z "$UNSIGNED_APP" ]; then
            echo "未找到 release 未签名的 APP 文件，尝试查找其他..."
            UNSIGNED_APP=$(find . -name "*-unsigned.app" -type f | head -1)
          fi
          
          # 如果找不到未签名的 APP，尝试查找未签名的 HAP
          if [ -z "$UNSIGNED_APP" ]; then
            echo "未找到未签名的 APP 文件，尝试查找未签名的 HAP 文件..."
            UNSIGNED_HAP=$(find . -name "*release-unsigned.hap" -type f | head -1)
            if [ -z "$UNSIGNED_HAP" ]; then
              UNSIGNED_HAP=$(find . -name "*-unsigned.hap" -type f | head -1)
            fi
            
            if [ -n "$UNSIGNED_HAP" ]; then
              echo "找到未签名的 HAP: $UNSIGNED_HAP"
              UNSIGNED_APP="$UNSIGNED_HAP"
            fi
          fi
          
          if [ -z "$UNSIGNED_APP" ]; then
            echo "错误：未找到任何未签名的构建产物"
            echo "搜索到的文件:"
            find . -name "*.app" -type f 2>/dev/null
            find . -name "*.hap" -type f 2>/dev/null
            exit 1
          fi
          
          echo "找到未签名的文件: $UNSIGNED_APP"
          
          # 根据文件类型确定扩展名
          if [[ "$UNSIGNED_APP" == *.app ]]; then
            EXTENSION=".app"
            BASENAME=$(basename "$UNSIGNED_APP" "-unsigned.app")
            OUTPUT_EXTENSION=".app"
          else
            EXTENSION=".hap"
            BASENAME=$(basename "$UNSIGNED_APP" "-unsigned.hap")
            OUTPUT_EXTENSION=".hap"
          fi
          
          # 生成签名后的文件名（添加版本号）
          SIGNED_FILE="build/${BASENAME}-v${{ env.VERSION }}-signed${OUTPUT_EXTENSION}"
          
          # 确保 build 目录存在
          mkdir -p build
          
          # 查找签名工具
          SIGN_TOOL=$(find /opt -name "hap-sign-tool.jar" -type f 2>/dev/null | head -1)
          
          echo "使用签名工具: $SIGN_TOOL"
          echo "输入文件: $UNSIGNED_APP"
          echo "输出文件: $SIGNED_FILE"
          echo "文件类型: ${EXTENSION:1}"  # 去掉点的扩展名
          
          # 执行签名
          java -jar "$SIGN_TOOL" \
            sign-app \
            -keyAlias "${{ env.SIGNING_KEY_ALIAS }}" \
            -signAlg "SHA256withECDSA" \
            -mode "localSign" \
            -appCertFile "./dis.cer" \
            -profileFile "./disRelease.p7b" \
            -inFile "$UNSIGNED_APP" \
            -keystoreFile "./dis.p12" \
            -outFile "$SIGNED_FILE" \
            -keyPwd "${{ env.KEYSTORE_PASSWORD }}" \
            -keystorePwd "${{ env.KEYSTORE_PASSWORD }}"
          
          if [ -f "$SIGNED_FILE" ]; then
            echo "签名成功: $SIGNED_FILE ($(du -h "$SIGNED_FILE" | cut -f1))"
          else
            echo "错误：签名失败"
            exit 1
          fi

      # 13. 处理构建产物以便上传到 GitHub Release
      - name: Prepare Artifacts for Release
        run: |
          cd ${{ env.PROJECT_PATH }}
          echo "=== 处理构建产物以便上传到 GitHub Release ==="
          
          # 查找所有签名文件（APP 和 HAP）
          echo "搜索签名文件..."
          SIGNED_APP=$(find . -name "*-v${{ env.VERSION }}-signed.app" -type f 2>/dev/null | head -1)
          SIGNED_HAP=$(find . -name "*-v${{ env.VERSION }}-signed.hap" -type f 2>/dev/null | head -1)
          
          # 优先使用 APP 文件
          if [ -n "$SIGNED_APP" ]; then
            PRIMARY_FILE="$SIGNED_APP"
            ORIGINAL_EXTENSION=".app"
            echo "找到 APP 文件: $PRIMARY_FILE"
          elif [ -n "$SIGNED_HAP" ]; then
            PRIMARY_FILE="$SIGNED_HAP"
            ORIGINAL_EXTENSION=".hap"
            echo "找到 HAP 文件: $PRIMARY_FILE"
          else
            # 如果没有带版本号的文件，使用第一个找到的签名文件
            PRIMARY_FILE=$(find . -name "*-signed.app" -type f 2>/dev/null | head -1)
            if [ -n "$PRIMARY_FILE" ]; then
              ORIGINAL_EXTENSION=".app"
            else
              PRIMARY_FILE=$(find . -name "*-signed.hap" -type f 2>/dev/null | head -1)
              ORIGINAL_EXTENSION=".hap"
            fi
          fi
          
          if [ -z "$PRIMARY_FILE" ]; then
            echo "错误：未找到已签名的构建产物"
            exit 1
          fi
          
          echo "原始文件: $PRIMARY_FILE"
          
          # 获取原始文件名（不带路径）
          ORIGINAL_FILENAME=$(basename "$PRIMARY_FILE")
          
          # 华为 AppGallery 上传使用原始文件（.app 或 .hap）
          HUAWEI_UPLOAD_FILE="./$ORIGINAL_FILENAME"
          cp "$PRIMARY_FILE" "$HUAWEI_UPLOAD_FILE"
          echo "华为上传文件: $HUAWEI_UPLOAD_FILE"
          
          # 创建新的文件名用于 GitHub Release（将 .app 改为 .zip，.hap 保持不变）
          if [[ "$ORIGINAL_EXTENSION" == ".app" ]]; then
            # 对于 .app 文件，改为 .zip 扩展名以便 GitHub 接受
            UPLOAD_FILENAME="${ORIGINAL_FILENAME%.app}.zip"
            UPLOAD_EXTENSION=".zip"
            FILE_TYPE="app"
          else
            # 对于 .hap 文件，保持原样
            UPLOAD_FILENAME="$ORIGINAL_FILENAME"
            UPLOAD_EXTENSION=".hap"
            FILE_TYPE="hap"
          fi
          
          # 复制文件到根目录，并根据需要重命名
          if [[ "$ORIGINAL_EXTENSION" == ".app" ]]; then
            # 对于 .app 文件，创建 zip 文件
            echo "创建 ZIP 文件以便上传到 GitHub Release..."
            zip -j "./$UPLOAD_FILENAME" "$PRIMARY_FILE"
            FINAL_FILE_PATH="./$UPLOAD_FILENAME"
          else
            # 对于 .hap 文件，直接复制
            cp "$PRIMARY_FILE" "./$UPLOAD_FILENAME"
            FINAL_FILE_PATH="./$UPLOAD_FILENAME"
          fi
          
          echo "最终上传文件: $FINAL_FILE_PATH"
          echo "上传文件名: $UPLOAD_FILENAME"
          echo "原始类型: ${ORIGINAL_EXTENSION:1}"
          echo "上传类型: ${UPLOAD_EXTENSION:1}"
          
          # 将文件信息保存到环境变量
          echo "ARTIFACT_FILE=$FINAL_FILE_PATH" >> $GITHUB_ENV
          echo "ARTIFACT_FILENAME=$UPLOAD_FILENAME" >> $GITHUB_ENV
          echo "ORIGINAL_FILENAME=$ORIGINAL_FILENAME" >> $GITHUB_ENV
          echo "FILE_TYPE=$FILE_TYPE" >> $GITHUB_ENV
          echo "ORIGINAL_EXTENSION=$ORIGINAL_EXTENSION" >> $GITHUB_ENV
          # 华为上传使用原始格式的文件
          echo "HUAWEI_UPLOAD_FILE=$HUAWEI_UPLOAD_FILE" >> $GITHUB_ENV
          
          # 验证文件存在
          if [ -f "$FINAL_FILE_PATH" ]; then
            size=$(du -h "$FINAL_FILE_PATH" | cut -f1)
            echo "✅ 准备上传: $UPLOAD_FILENAME (${UPLOAD_EXTENSION:1}, $size)"
            
            # 如果是 ZIP 文件，显示内容信息
            if [[ "$UPLOAD_EXTENSION" == ".zip" ]]; then
              echo "ZIP 文件内容:"
              unzip -l "$FINAL_FILE_PATH" | head -5
            fi
          else
            echo "❌ 错误：文件不存在: $FINAL_FILE_PATH"
            exit 1
          fi

      - name: Upload to Huawei AppGallery
        env:
          HUAWEI_CLIENT_ID: ${{ secrets.HUAWEI_CLIENT_ID }}
          HUAWEI_CLIENT_SECRET: ${{ secrets.HUAWEI_CLIENT_SECRET }}
          HUAWEI_APP_ID: ${{ secrets.HUAWEI_APP_ID }}
          HUAWEI_RELEASE_TYPE: ${{ secrets.HUAWEI_RELEASE_TYPE || '1' }}
          HUAWEI_CHINA_MAINLAND_FLAG: ${{ secrets.HUAWEI_CHINA_MAINLAND_FLAG || '1' }}
          HUAWEI_UPLOAD_FILE: ${{ env.HUAWEI_UPLOAD_FILE }}
          ORIGINAL_FILENAME: ${{ env.ORIGINAL_FILENAME }}
        run: |
          set -euo pipefail

          FILE_PATH="${HUAWEI_UPLOAD_FILE:-}"
          FILE_NAME="${ORIGINAL_FILENAME:-}"

          if [ -z "${HUAWEI_CLIENT_ID:-}" ] || [ -z "${HUAWEI_CLIENT_SECRET:-}" ] || [ -z "${HUAWEI_APP_ID:-}" ]; then
            echo "❌ 缺少华为上传所需密钥"
            exit 1
          fi

          if [ -z "$FILE_PATH" ] || [ ! -f "$FILE_PATH" ]; then
            echo "❌ 上传文件不存在: $FILE_PATH"
            exit 1
          fi

          # 清理隐藏换行，避免 header/query 参数污染导致 403
          HUAWEI_CLIENT_ID="$(echo -n "$HUAWEI_CLIENT_ID" | tr -d '\r\n')"
          HUAWEI_CLIENT_SECRET="$(echo -n "$HUAWEI_CLIENT_SECRET" | tr -d '\r\n')"
          HUAWEI_APP_ID="$(echo -n "$HUAWEI_APP_ID" | tr -d '\r\n')"
          HUAWEI_RELEASE_TYPE="$(echo -n "${HUAWEI_RELEASE_TYPE:-1}" | tr -d '\r\n')"
          HUAWEI_CHINA_MAINLAND_FLAG="$(echo -n "${HUAWEI_CHINA_MAINLAND_FLAG:-1}" | tr -d '\r\n')"

          FILE_NAME="$(basename "$FILE_NAME" | tr -d '\r\n')"
          [ -z "$FILE_NAME" ] && FILE_NAME="$(basename "$FILE_PATH")"

          FILE_SIZE=$(wc -c < "$FILE_PATH" | tr -d ' ')
          SHA256=$(sha256sum "$FILE_PATH" | awk '{print $1}')
          echo "📦 待上传: $FILE_NAME ($(du -h "$FILE_PATH" | cut -f1), SHA256: ${SHA256:0:16}...)"

          # ── Step 1: 获取 Access Token ──
          echo "📤 获取 Access Token..."
          TOKEN_RESP=$(curl -sS -X POST \
            -H "Content-Type: application/json" \
            -d "{\"grant_type\":\"client_credentials\",\"client_id\":\"${HUAWEI_CLIENT_ID}\",\"client_secret\":\"${HUAWEI_CLIENT_SECRET}\"}" \
            "https://connect-api.cloud.huawei.com/api/oauth2/v1/token")

          if ! echo "$TOKEN_RESP" | jq empty >/dev/null 2>&1; then
            echo "❌ Token API 返回非 JSON 响应"
            echo "$TOKEN_RESP"
            exit 1
          fi

          ACCESS_TOKEN=$(echo "$TOKEN_RESP" | jq -r '.access_token // empty')
          if [ -z "$ACCESS_TOKEN" ]; then
            echo "❌ 获取 access_token 失败"
            echo "$TOKEN_RESP" | jq .
            exit 1
          fi
          echo "✅ Access Token 获取成功"

          # ── Step 2: 获取上传地址（按你可用 curl 形式） ──
          echo "📤 获取上传地址..."
          UPLOAD_URL_RESP=$(curl -sS -w "\n%{http_code}" -G \
            "https://connect-api.cloud.huawei.com/api/publish/v2/upload-url/for-obs" \
            -H "Authorization: Bearer ${ACCESS_TOKEN}" \
            -H "Host: connect-api.cloud.huawei.com" \
            -H "client_id: ${HUAWEI_CLIENT_ID}" \
            --data-urlencode "appId=${HUAWEI_APP_ID}" \
            --data-urlencode "fileName=${FILE_NAME}" \
            --data-urlencode "contentLength=${FILE_SIZE}" \
            --data-urlencode "sha256=${SHA256}" \
            --data-urlencode "releaseType=${HUAWEI_RELEASE_TYPE}" \
            --data-urlencode "chineseMainlandFlag=${HUAWEI_CHINA_MAINLAND_FLAG}")

          HTTP_CODE=$(echo "$UPLOAD_URL_RESP" | tail -n1)
          RESP_BODY=$(echo "$UPLOAD_URL_RESP" | sed '$d')

          if [ "$HTTP_CODE" -ne 200 ]; then
            echo "❌ 获取上传地址失败 (HTTP $HTTP_CODE)"
            echo "$RESP_BODY" | jq . 2>/dev/null || echo "$RESP_BODY"
            exit 1
          fi

          RET_CODE=$(echo "$RESP_BODY" | jq -r '.ret.code // empty')
          RET_MSG=$(echo "$RESP_BODY" | jq -r '.ret.msg // empty')
          if [ -n "$RET_CODE" ] && [ "$RET_CODE" != "0" ]; then
            echo "❌ 获取上传地址失败: ret.code=$RET_CODE, msg=$RET_MSG"
            exit 1
          fi

          UPLOAD_URL=$(echo "$RESP_BODY" | jq -r '.urlInfo.url // empty')
          UPLOAD_HDR_AUTH=$(echo "$RESP_BODY" | jq -r '.urlInfo.headers.Authorization // empty')
          UPLOAD_HDR_SHA256=$(echo "$RESP_BODY" | jq -r '.urlInfo.headers."x-amz-content-sha256" // empty')
          UPLOAD_HDR_DATE=$(echo "$RESP_BODY" | jq -r '.urlInfo.headers."x-amz-date" // empty')
          UPLOAD_HDR_HOST=$(echo "$RESP_BODY" | jq -r '.urlInfo.headers.Host // empty')
          UPLOAD_HDR_UA=$(echo "$RESP_BODY" | jq -r '.urlInfo.headers."user-agent" // empty')
          UPLOAD_HDR_CT=$(echo "$RESP_BODY" | jq -r '.urlInfo.headers."Content-Type" // "application/octet-stream"')

          if [ -z "$UPLOAD_URL" ]; then
            echo "❌ 获取上传地址失败: urlInfo.url 为空"
            echo "$RESP_BODY" | jq .
            exit 1
          fi
          echo "✅ 上传地址获取成功"

          # ── Step 3: 上传文件 (PUT to OBS) ──
          echo "📤 上传文件到华为 OBS..."
          CURL_ARGS=(-sS -w "\n%{http_code}" -X PUT --upload-file "$FILE_PATH")
          [ -n "$UPLOAD_HDR_AUTH" ]   && CURL_ARGS+=(-H "Authorization: $UPLOAD_HDR_AUTH")
          [ -n "$UPLOAD_HDR_SHA256" ] && CURL_ARGS+=(-H "x-amz-content-sha256: $UPLOAD_HDR_SHA256")
          [ -n "$UPLOAD_HDR_DATE" ]   && CURL_ARGS+=(-H "x-amz-date: $UPLOAD_HDR_DATE")
          [ -n "$UPLOAD_HDR_HOST" ]   && CURL_ARGS+=(-H "Host: $UPLOAD_HDR_HOST")
          [ -n "$UPLOAD_HDR_UA" ]     && CURL_ARGS+=(-H "user-agent: $UPLOAD_HDR_UA")
          [ -n "$UPLOAD_HDR_CT" ]     && CURL_ARGS+=(-H "Content-Type: $UPLOAD_HDR_CT")

          UPLOAD_RESP=$(curl "${CURL_ARGS[@]}" "$UPLOAD_URL")
          UPLOAD_HTTP_CODE=$(echo "$UPLOAD_RESP" | tail -n1)
          UPLOAD_RESP_BODY=$(echo "$UPLOAD_RESP" | sed '$d')

          if [ "$UPLOAD_HTTP_CODE" = "200" ] || [ "$UPLOAD_HTTP_CODE" = "201" ] || [ "$UPLOAD_HTTP_CODE" = "204" ]; then
            echo "✅ 华为 AppGallery 上传成功！($FILE_NAME, $(du -h "$FILE_PATH" | cut -f1))"
          else
            echo "❌ 上传失败 (HTTP $UPLOAD_HTTP_CODE)"
            echo "$UPLOAD_RESP_BODY"
            exit 1
          fi
      

      # 14. 创建 GitHub Release
      - name: Create GitHub Release
        id: create_release
        uses: softprops/action-gh-release@v1
        with:
          # 使用 tag 名称作为 Release 名称
          name: ${{ env.RELEASE_NAME }}
          
          # Release 说明
          body: |
            # HarmonyOS 应用发布 - ${{ env.VERSION }}
            
            ## 🚀 版本信息
            - **版本号**: ${{ env.VERSION }}
            - **Tag**: ${{ env.TAG_NAME }}
            - **构建时间**: ${{ github.event.head_commit.timestamp }}
            - **提交**: [${{ github.sha }}](https://github.com/${{ github.repository }}/commit/${{ github.sha }})
            
            ## 📦 构建产物
            下方提供了已签名的 HarmonyOS 应用文件，可直接安装到 HarmonyOS 设备。
            
            ### 文件信息
            - **下载文件名**: ${{ env.ARTIFACT_FILENAME }}
            - **原始类型**: ${{ env.FILE_TYPE == 'app' && 'APP 文件' || 'HAP 文件' }}
            - **上传格式**: ${{ contains(env.ARTIFACT_FILENAME, '.zip') && 'ZIP 压缩包' || 'HAP 文件' }}
            
            ## 📱 安装说明
            
            ### 对于 APP 文件（.zip 格式）:
            1. 下载 **${{ env.ARTIFACT_FILENAME }}** 文件
            2. 解压 ZIP 文件，获取 **${{ env.ORIGINAL_FILENAME }}**
            3. 将解压后的文件传输到 HarmonyOS 设备
            4. 使用以下命令安装：
            ```bash
            hdc install ${{ env.ORIGINAL_FILENAME }}
            ```
            
            ### 对于 HAP 文件:
            1. 下载 **${{ env.ARTIFACT_FILENAME }}** 文件
            2. 将文件传输到 HarmonyOS 设备
            3. 使用以下命令安装：
            ```bash
            hdc install ${{ env.ARTIFACT_FILENAME }}
            ```
            
            4. 或在设备文件管理器中直接点击安装
            
            ## 🔧 构建信息
            - 构建系统: GitHub Actions
            - 构建环境: Ubuntu Linux
            - HarmonyOS SDK: 6.0.2.640
            - 构建工具: hvigorw assembleApp
            
            ---
            
            *此 Release 由 GitHub Actions 自动构建和发布*
          
          # 使用现有的 tag
          tag_name: ${{ env.TAG_NAME }}
          
          # 是否为草稿
          draft: false
          
          # 是否为预发布
          prerelease: ${{ contains(env.TAG_NAME, 'beta') || contains(env.TAG_NAME, 'alpha') || contains(env.TAG_NAME, 'rc') || contains(env.TAG_NAME, 'preview') }}
          
          # 生成发布说明
          generate_release_notes: true
          
          # 上传文件
          files: |
            ${{ env.ARTIFACT_FILE }}
          
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # 15. 构建完成通知
      - name: Build Complete
        run: |
          echo "🎉 HarmonyOS 应用构建和发布完成！"
          echo ""
          echo "📋 发布信息:"
          echo "  - 版本: ${{ env.VERSION }}"
          echo "  - Tag: ${{ env.TAG_NAME }}"
          echo "  - Release: ${{ steps.create_release.outputs.html_url }}"
          echo "  - 构建产物: ${{ env.ARTIFACT_FILENAME }}"
          echo "  - 原始文件: ${{ env.ORIGINAL_FILENAME }}"
          echo ""
          
          # 显示文件信息
          if [ -f "${{ env.ARTIFACT_FILE }}" ]; then
            size=$(du -h "${{ env.ARTIFACT_FILE }}" | cut -f1)
            sha=$(sha256sum "${{ env.ARTIFACT_FILE }}" | cut -d' ' -f1)
            echo "📦 文件详情:"
            echo "  - 上传文件名: ${{ env.ARTIFACT_FILENAME }}"
            echo "  - 原始文件名: ${{ env.ORIGINAL_FILENAME }}"
            echo "  - 文件类型: ${{ env.FILE_TYPE == 'app' && 'APP (打包为ZIP)' || 'HAP' }}"
            echo "  - 大小: $size"
            echo "  - SHA256: $sha"
            
            # 如果是 ZIP 文件，显示解压说明
            if [[ "${{ env.ARTIFACT_FILENAME }}" == *.zip ]]; then
              echo ""
              echo "📝 使用说明:"
              echo "  1. 下载 ${{ env.ARTIFACT_FILENAME }}"
              echo "  2. 解压获取 ${{ env.ORIGINAL_FILENAME }}"
              echo "  3. 使用 hdc install ${{ env.ORIGINAL_FILENAME }} 安装"
            fi
          fi
